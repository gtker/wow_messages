#[allow(clippy::too_many_arguments)]
pub(crate) mod constructors;
#[allow(non_upper_case_globals)]
mod data;

#[rustfmt::skip]
mod definition;

// AUTOGENERATED_START
pub use wow_world_base::wrath::{
    AllowedClass, AllowedRace, Area, BagFamily, Bonding, Faction, Gold, InventoryType, 
    ItemClassAndSubClass, ItemDamageType, ItemFlag, ItemFlag2, ItemQuality, ItemSet, 
    ItemSocket, ItemStat, Language, Map, PageTextMaterial, PvpRank, SheatheType, 
    Skill, SpellSchool, SpellTriggerType,
};

pub use crate::wrath::definition::{
    Item, Spells,
};

/// Looks up items and returns if found.
///
/// Prefer using this over [`all_items`] since this utilizes a lookup array for very fast lookup.
pub const fn lookup_item(id: u32) -> Option<&'static Item> {
    if id < 17 || id > 56806 {
        return None;
    }

    let index = data::Z________LOOKUP[(id - 17) as usize];
    if index == u16::MAX || index as usize > (all_items().len() - 1) {
        None
    } else {
        Some(&all_items()[index as usize])
    }
}

/// Returns all items.
///
/// Prefer using [`lookup_item`] since it incorporates optimizations for lookup speed.
pub const fn all_items() -> &'static [Item] {
    data::Z________DATA
}

/// Returns all items that contain `needle` in the name. The search is case insensitive.
pub fn lookup_items_by_name(needle: &str) -> impl Iterator<Item = &'static Item> + '_ {
    all_items().iter().filter(move |item| {
        let lower = item.name().to_ascii_lowercase();
        lower.contains(needle)
    })
}

/// Returns the first item that contains `needle` in the name. The search is case insensitive.
pub fn lookup_item_by_name(needle: &str) -> Option<&'static Item> {
    let needle = needle.to_ascii_lowercase();

    for item in all_items() {
        let lower = item.name().to_ascii_lowercase();
        if lower.contains(&needle) {
            return Some(item)
        }

    }

    None
}

#[cfg(test)]
mod test {
    use super::lookup_item;

    #[test]
    fn tests() {
        assert!(lookup_item(u32::MIN).is_none());
        assert!(lookup_item(u32::MAX).is_none());

        const MIN: u32 = 17;
        const MAX: u32 = 56806;
        assert_eq!(lookup_item(MIN).unwrap().entry(), MIN);
        assert_eq!(lookup_item(MAX).unwrap().entry(), MAX);

        assert!(lookup_item(MIN - 1).is_none());
        assert!(lookup_item(MAX + 1).is_none());

        for i in 0..=MAX + 10 {
            match lookup_item(i) {
                None => {}
                Some(e) => assert_eq!(i, e.entry()),
            }
        }
    }
}
// AUTOGENERATED_END
