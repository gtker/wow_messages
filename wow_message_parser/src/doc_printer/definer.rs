use crate::file_info::FileInfo;
use crate::parser::types::definer::Definer;
use crate::parser::types::IntegerType;
use crate::rust_printer::writer::Writer;
use crate::wowm_printer::get_definer_wowm_definition;
use crate::{doc_printer, ObjectTags};

fn definer_common(
    s: &mut Writer,
    tags: &ObjectTags,
    fileinfo: &FileInfo,
    ty: &str,
    e: &Definer,
    print_header: bool,
) {
    doc_printer::common(s, tags, e.name(), print_header);

    s.wln("### Wowm Representation");
    s.newline();

    s.wln(format!(
        "Autogenerated from `wowm` file at {github_link}.",
        github_link = fileinfo.original_file_github_link()
    ));
    s.newline();
    s.wln("```rust,ignore");
    s.w(get_definer_wowm_definition(ty, e, ""));
    s.wln("```");
}

pub(crate) fn print_docs_for_enum(e: &Definer, print_header: bool) -> Writer {
    let mut s = Writer::new();

    definer_common(&mut s, e.tags(), e.file_info(), "enum", e, print_header);

    print_definer_table(&mut s, e);

    s.wln("Used in:");
    for c in e.objects_used_in() {
        s.wln(format!(
            "* [{ty}]({ty_path}.md)",
            ty = c.0,
            ty_path = c.0.to_lowercase(),
        ));
    }
    s.newline();

    s
}

pub(crate) fn print_docs_for_flag(e: &Definer, print_header: bool) -> Writer {
    let mut s = Writer::new();

    definer_common(&mut s, e.tags(), e.file_info(), "flag", e, print_header);

    print_definer_table(&mut s, e);

    s.wln("Used in:");
    for c in e.objects_used_in() {
        s.wln(format!(
            "* [{ty}]({ty_path}.md)",
            ty = c.0,
            ty_path = c.0.to_lowercase(),
        ));
    }

    s
}

fn print_definer_table(s: &mut Writer, e: &Definer) {
    s.wln("### Type");
    s.wln(format!(
        "The basic type is `{ty_str}`, a {byte} byte ({bit} bit){endian} integer.",
        ty_str = e.ty().str(),
        byte = e.ty().size(),
        bit = e.ty().size() * 8,
        endian = match e.ty() {
            IntegerType::I8 | IntegerType::U8 => "",
            IntegerType::U16
            | IntegerType::U32
            | IntegerType::I16
            | IntegerType::I64
            | IntegerType::U64
            | IntegerType::I32 => " little endian",

            IntegerType::U48 => " 32bit little endian followed by 16 bit little endian",
        }
    ));

    s.wln("### Enumerators");

    let any_fields_has_display = e.fields().iter().any(|f| f.tags().display().is_some());

    s.w("| Enumerator | Value  | Description | Comment |");
    if any_fields_has_display {
        s.wln(" Display |");
    } else {
        s.newline();
    }

    s.w("| --------- | -------- | ----------- | ------- |");
    if any_fields_has_display {
        s.wln(" ------- |");
    } else {
        s.newline();
    }

    for f in e.fields() {
        let description = if let Some(d) = f.tags().description() {
            d.as_doc_table_string()
        } else {
            "".to_string()
        };

        let comment = if let Some(d) = f.tags().comment() {
            d.as_doc_table_string()
        } else {
            "".to_string()
        };

        s.w(format!(
            "| `{name}` | {value} (0x{hex:0>2X}) | {description} | {comment} |",
            name = f.name(),
            value = f.value().int(),
            hex = f.value().int(),
            description = description,
            comment = comment,
        ));
        if any_fields_has_display {
            s.wln(format!(" {} |", f.tags().display().unwrap_or("")));
        } else {
            s.newline();
        }
    }

    s.newline();
}
