use crate::parser::types::array::{Array, ArraySize, ArrayType};
use crate::parser::types::if_statement::{Equation, IfStatement};
use crate::parser::types::sizes::SPELL_SIZE;
use crate::parser::types::struct_member::{StructMember, StructMemberDefinition};
use crate::parser::types::ty::Type;
use crate::parser::types::IntegerType;
use crate::rust_printer::writer::Writer;
use crate::wowm_printer::get_struct_wowm_definition;
use crate::{doc_printer, Container, ContainerType, DefinerType, ObjectTags, Objects};
use hashbrown::HashMap;
use std::convert::TryInto;
use std::fmt::Write;
use std::io::Read;
use std::slice::Iter;

pub(crate) fn print_docs_for_container(e: &Container, o: &Objects, print_header: bool) -> Writer {
    let mut s = Writer::new();

    doc_printer::common(&mut s, e.tags(), e.name(), print_header);

    s.wln("### Wowm Representation");
    s.newline();
    s.wln(format!(
        "Autogenerated from `wowm` file at {github_link}.",
        github_link = e.file_info().original_file_github_link()
    ));
    s.wln("```rust,ignore");
    s.w(get_struct_wowm_definition(e, ""));
    s.wln("```");

    print_container_header(&mut s, e);
    print_container_body(&mut s, e, o);

    print_container_examples(&mut s, e, o);

    if let Some(objects) = e.objects_used_in() {
        s.newline();
        s.wln("Used in:");
        for c in objects {
            s.wln(format!(
                "* [{ty}]({ty_path}.md)",
                ty = c,
                ty_path = c.to_lowercase(),
            ));
        }
        s.newline();
    }

    s
}

fn print_container_example_array(
    s: &mut Writer,
    array: &Array,
    bytes: &mut Iter<u8>,
    values: &mut HashMap<String, i128>,
    o: &Objects,
    tags: &ObjectTags,
    prefix: &str,
) {
    let size = match array.size() {
        ArraySize::Fixed(size) => size as usize,
        ArraySize::Variable(m) => *values.get(m.name()).unwrap() as usize,
        ArraySize::Endless => {
            let size = bytes.size_hint();
            assert_eq!(size.0, size.1.unwrap());
            size.0
        }
    };

    for i in 0..size {
        // Edge case: Endless arrays of complex types do not have always have a fixed type, so we just loop until we run out of bytes to read instead.
        if let ArrayType::Struct(_) = array.ty() {
            if ArraySize::Endless == array.size() && bytes.len() == 0 {
                return;
            }
        }

        match array.ty() {
            ArrayType::Integer(t) => {
                let bytes = bytes.take(t.size() as usize);

                for b in bytes {
                    s.w_break_at(format!("{b}, "));
                }
            }
            ArrayType::Spell => {
                let bytes = bytes.take(SPELL_SIZE.into());

                for b in bytes {
                    s.w_break_at(format!("{b}, "));
                }
            }
            ArrayType::CString => {
                let mut b = bytes.next().unwrap();
                while *b != 0 {
                    s.w_break_at(format!("{b}, "));
                    b = bytes.next().unwrap();
                }
                s.w_break_at(format!("{b}, "));
            }
            ArrayType::Guid => {
                let bytes = bytes.take(core::mem::size_of::<u64>());

                for b in bytes {
                    s.w_break_at(format!("{b}, "));
                }
            }
            ArrayType::PackedGuid => {
                let mask = bytes.next().unwrap();
                let bytes = bytes.take(mask.count_ones() as _);
                for b in bytes {
                    s.w_break_at(format!("{b}, "));
                }
            }
            ArrayType::Struct(c) => {
                for m in c.members() {
                    let prefix = format!("{}[{}].{}", prefix, i, c.name());
                    print_container_example_member(s, m, bytes, values, o, tags, &prefix);
                }
            }
        }
    }
}

fn print_container_example_definition(
    s: &mut Writer,
    d: &StructMemberDefinition,
    bytes: &mut Iter<u8>,
    values: &mut HashMap<String, i128>,
    o: &Objects,
    tags: &ObjectTags,
    prefix: &str,
) {
    let comment = if !prefix.is_empty() {
        format!("// {}.{}: {}", prefix, d.name(), d.ty().str())
    } else {
        format!("// {}: {}", d.name(), d.ty().str())
    };

    match d.ty() {
        Type::Integer(t) => {
            let bytes = bytes.take(t.size() as usize).cloned().collect::<Vec<u8>>();

            let value = bytes.clone();
            let value = get_integer_value(t, value.as_slice());
            values.insert(d.name().to_string(), value);

            for b in bytes {
                s.w(format!("{b}, "));
            }
        }
        Type::PackedGuid => {
            let mask = bytes.next().unwrap();
            s.w(format!("{mask}, "));
            let bytes = bytes.take(mask.count_ones() as _);
            s.bytes(bytes);
        }
        Type::CString => {
            let mut b = bytes.next().unwrap();
            while *b != 0 {
                s.w(format!("{b}, "));
                b = bytes.next().unwrap();
            }
            s.w(format!("{b}, "));
        }
        Type::String => {
            let length = bytes.next().unwrap();
            s.wln(format!("{length}, // string length"));
            s.bytes(bytes.take((*length) as usize));
        }
        Type::Array(array) => {
            print_container_example_array(s, array, bytes, values, o, tags, prefix);
        }
        Type::Enum { e, upcast } | Type::Flag { e, upcast } => {
            let ty = if let Some(ty) = upcast { ty } else { e.ty() };

            let bytes = bytes.take(ty.size() as usize).cloned().collect::<Vec<u8>>();

            let value = get_integer_value(ty, bytes.as_slice());
            values.insert(d.name().to_string(), value);
            for b in bytes {
                s.w(format!("{b}, "));
            }

            let c = match e.definer_ty() {
                DefinerType::Enum => {
                    if let Some(value) = e.get_field_with_value(value) {
                        let name = value.name();
                        let value = value.value().original();
                        format!("{comment} {name} ({value})")
                    } else {
                        panic!(
                            "unable to find field with value '{}' for variable: '{}'",
                            value,
                            d.name()
                        )
                    }
                }
                DefinerType::Flag => {
                    let values = e.get_set_flag_fields(value);
                    let mut t = comment;
                    t.push(' ');

                    for (i, v) in values.iter().enumerate() {
                        if i != 0 {
                            t.push_str("| ");
                        } else {
                            t.push(' ');
                        }
                        t.push_str(v.name());
                    }

                    write!(t, " ({value})").unwrap();
                    t
                }
            };

            s.wln(c);
            return;
        }
        Type::Struct { e } => {
            for m in e.members() {
                print_container_example_member(s, m, bytes, values, o, tags, e.name());
            }

            return;
        }
        Type::UpdateMask { .. } => {
            s.wln("// UpdateMask");
            let amount_of_blocks = bytes.next().unwrap();
            s.wln(format!("{amount_of_blocks}, // amount_of_blocks"));

            let blocks: Vec<&u8> = bytes.take(4 * *amount_of_blocks as usize).collect();
            let blocks = blocks.chunks(4);
            for (i, block) in blocks.clone().enumerate() {
                s.wln(format!(
                    "{}, {}, {}, {}, // Block {}",
                    block[0], block[1], block[2], block[3], i
                ));
            }
            let blocks = blocks.map(|a| u32::from_le_bytes([*a[0], *a[1], *a[2], *a[3]]));
            for block in blocks {
                for bit in 0..32 {
                    if (block & 1 << bit) != 0 {
                        s.bytes(bytes.take(4));
                        s.wln_no_indent("// Item");
                    }
                }
            }
        }
        Type::AuraMask => unimplemented!("AuraMask example"),
        Type::SizedCString => {
            let b = bytes.take(4).cloned().collect::<Vec<u8>>();

            for b in b {
                s.w(format!("{b}, "));
            }
            s.wln(" // SizedCString.length");

            let mut b = bytes.next().unwrap();
            while *b != 0 {
                s.w(format!("{b}, "));
                b = bytes.next().unwrap();
            }
            s.w(format!("{b}, "));
        }
        Type::MonsterMoveSplines => {
            unimplemented!("monster move spline doc printer")
        }
        Type::AchievementDoneArray | Type::AchievementInProgressArray => {
            unimplemented!("-1 delimited achievement arrays")
        }
        Type::EnchantMask => {
            unimplemented!("enchant mask example")
        }
        Type::InspectTalentGearMask => {
            unimplemented!("inspect talent gear mask example")
        }
        Type::NamedGuid => unimplemented!("named guid example"),
        Type::VariableItemRandomProperty => {
            unimplemented!("variable item random property id example")
        }
        Type::AddonArray => {
            unimplemented!("addon array example")
        }

        _ => {
            let size = d.ty().sizes().is_constant().unwrap();
            s.bytes(bytes.take(size.try_into().unwrap()));
        }
    }
    s.wln(comment);
}

fn print_container_example_member(
    s: &mut Writer,
    m: &StructMember,
    bytes: &mut Iter<u8>,
    values: &mut HashMap<String, i128>,
    o: &Objects,
    tags: &ObjectTags,
    prefix: &str,
) {
    match m {
        StructMember::Definition(d) => {
            if let Some(compressed) = d.compressed_definition() {
                print_container_example_definition(s, &compressed, bytes, values, o, tags, prefix);

                let mut decoded_bytes = Vec::new();
                let mut decoder = flate2::read::ZlibDecoder::new(bytes.as_slice());
                decoder
                    .read_to_end(&mut decoded_bytes)
                    .expect("Failed to decode ZLib compressed field.");

                print_container_example_definition(
                    s,
                    d,
                    &mut decoded_bytes.iter(),
                    values,
                    o,
                    tags,
                    prefix,
                );
            } else {
                print_container_example_definition(s, d, bytes, values, o, tags, prefix);
            }
        }
        StructMember::IfStatement(statement) => {
            let enum_value = *values.get(statement.variable_name()).unwrap();

            let definer_ty = match statement.original_ty() {
                Type::Enum { e, .. } | Type::Flag { e, .. } => e,
                _ => unreachable!("Non definer used in original type"),
            };

            let statement_set = |statement: &IfStatement, enum_value: i128| {
                let mut set = false;
                match statement.equation() {
                    Equation::Equals { values: value } => {
                        for v in value {
                            let eq_value = definer_ty
                                .fields()
                                .iter()
                                .find(|a| v == a.name())
                                .unwrap()
                                .value()
                                .int();

                            if eq_value == enum_value {
                                set = true;
                            }
                        }
                    }
                    Equation::BitwiseAnd { values: value } => {
                        for v in value {
                            let eq_value = definer_ty
                                .fields()
                                .iter()
                                .find(|a| v == a.name())
                                .unwrap()
                                .value()
                                .int();

                            if (eq_value == 0 && enum_value == 0) || (eq_value & enum_value) != 0 {
                                set = true;
                            }
                        }
                    }
                    Equation::NotEquals { .. } => {
                        unimplemented!("examples for not equals")
                    }
                }
                set
            };

            if statement_set(statement, enum_value) {
                for m in statement.members() {
                    print_container_example_member(s, m, bytes, values, o, tags, prefix);
                }
            } else if !statement.else_ifs().is_empty() {
                for elseif in statement.else_ifs() {
                    let value = *values.get(elseif.variable_name()).unwrap();

                    if statement_set(elseif, value) {
                        for m in elseif.members() {
                            print_container_example_member(s, m, bytes, values, o, tags, prefix);
                        }
                    }
                }
            } else {
                for m in statement.else_members() {
                    print_container_example_member(s, m, bytes, values, o, tags, prefix);
                }
            }
        }
        StructMember::OptionalStatement(optional) => {
            if bytes.len() != 0 {
                s.wln(format!("// Optional {}", optional.name()));

                for m in optional.members() {
                    print_container_example_member(s, m, bytes, values, o, tags, prefix);
                }
            }
        }
    }
}

fn print_container_example_header(s: &mut Writer, e: &Container, bytes: &mut Iter<u8>) {
    match e.container_type() {
        ContainerType::CLogin(o) | ContainerType::SLogin(o) => {
            let bytes = bytes.take(core::mem::size_of::<u8>());
            s.bytes(bytes);
            s.wln(format!("// opcode ({o})"));
            return;
        }
        ContainerType::CMsg(_) | ContainerType::SMsg(_) => {
            let size = bytes.take(core::mem::size_of::<u16>());
            s.bytes(size);
            s.wln("// size");
        }
        ContainerType::Msg(_) => unimplemented!("MSG container example header"),
        ContainerType::Struct => unreachable!("struct not supported"),
    }

    let (opcode, o) = match e.container_type() {
        ContainerType::CMsg(o) => (bytes.take(core::mem::size_of::<u32>()), o),
        ContainerType::SMsg(o) => (bytes.take(core::mem::size_of::<u16>()), o),
        _ => unimplemented!("msg in container examples"),
    };
    s.bytes(opcode);
    s.wln(format!("// opcode ({o})"));
}

fn print_container_examples(s: &mut Writer, e: &Container, o: &Objects) {
    if e.tests(o).is_empty() {
        return;
    }

    s.wln("### Examples");
    s.newline();

    for (i, t) in e.tests(o).iter().enumerate() {
        s.wln(format!("#### Example {}", i + 1));
        s.newline();

        if let Some(comment) = t.tags().comment() {
            s.wln("##### Comment");
            s.newline();
            for l in comment.as_doc_lines() {
                s.wln(l);
                s.newline();
            }
        }

        s.wln("```c");
        let mut bytes = t.raw_bytes().iter();

        print_container_example_header(s, e, &mut bytes);

        let mut values = HashMap::new();

        if e.tags().compressed() {
            // All fully compressed messages have a u32 at the start with the decompressed size.
            let decompressed_size = bytes.clone().take(4);
            s.bytes(decompressed_size);
            s.w("// uncompressed size");
            s.newline();

            // The rest of the message is ZLib compressed.
            for b in bytes.skip(4) {
                s.w_break_at(format!("{b}, "));
            }
            s.w("// compressed data");
            s.newline();
        } else {
            for m in e.members() {
                print_container_example_member(s, m, &mut bytes, &mut values, o, e.tags(), "");
            }
        }

        s.wln("```");
    }
}

fn print_container_if_statement(
    s: &mut Writer,
    statement: &IfStatement,
    offset: &mut Option<i128>,
    tags: &ObjectTags,
    o: &Objects,
) {
    s.w(format!(
        "If {variable} ",
        variable = statement.variable_name()
    ));
    match statement.equation() {
        Equation::NotEquals { value } => {
            s.w(format!("is not equal to `{value}`"));
        }
        Equation::Equals { values: value } => {
            for (i, v) in value.iter().enumerate() {
                if i != 0 {
                    s.wln(" **or** ");
                }

                s.w(format!("is equal to `{v}`"));
            }
        }
        Equation::BitwiseAnd { values: value } => {
            for (i, v) in value.iter().enumerate() {
                if i != 0 {
                    s.wln(" **or** ");
                }

                s.w(format!("contains `{v}`"));
            }
        }
    }

    s.wln(":");
    s.newline();

    print_container_item_header(s);

    for m in statement.members() {
        print_container_field(s, m, offset, tags, o);
    }

    if !statement.else_ifs().is_empty() {
        for elseif in statement.else_ifs() {
            s.newline();
            s.w("Else ");
            print_container_if_statement(s, elseif, offset, tags, o);
        }
    }

    if !statement.else_members().is_empty() {
        s.newline();
        s.wln("Else: ");

        for m in statement.else_members() {
            print_container_field(s, m, offset, tags, o);
        }
    }
}

fn print_container_field(
    s: &mut Writer,
    m: &StructMember,
    offset: &mut Option<i128>,
    tags: &ObjectTags,
    o: &Objects,
) {
    match m {
        StructMember::Definition(d) => {
            let ty = match d.ty() {
                Type::Enum { e, .. } | Type::Flag { e, .. } => {
                    format!("[{}]({}.md)", d.ty().str(), e.name().to_lowercase())
                }
                Type::Struct { e, .. } => {
                    format!("[{}]({}.md)", d.ty().str(), e.name().to_lowercase())
                }
                Type::NamedGuid | Type::PackedGuid | Type::Guid => {
                    format!("[{}](../types/packed-guid.md)", d.ty().str())
                }
                Type::UpdateMask { .. } => {
                    format!("[{}](../types/update-mask.md)", d.ty().str())
                }
                Type::EnchantMask => {
                    format!("[{}](../types/enchant-mask.md)", d.ty().str())
                }
                Type::InspectTalentGearMask => {
                    format!("[{}](../types/inspect-talent-gear-mask.md)", d.ty().str())
                }
                Type::AuraMask => {
                    format!("[{}](../types/aura-mask.md)", d.ty().str())
                }
                Type::Array(array) => match array.ty() {
                    ArrayType::Spell | ArrayType::CString | ArrayType::Integer(_) => d.ty().str(),
                    ArrayType::Struct(c) => {
                        format!(
                            "[{ty}]({ty_path}.md)[{size}]",
                            ty = c.name(),
                            ty_path = c.name().to_lowercase(),
                            size = array.size().str(),
                        )
                    }
                    ArrayType::Guid => {
                        format!(
                            "[Guid](../types/packed-guid.md)[{size}]",
                            size = array.size().str()
                        )
                    }
                    ArrayType::PackedGuid => {
                        format!(
                            "[PackedGuid](../types/packed-guid.md)[{size}]",
                            size = array.size().str()
                        )
                    }
                },
                Type::AddonArray => "[AddonArray](../types/addon-array.md)".to_string(),
                Type::AchievementDoneArray => {
                    "[AchievementDoneArray](../types/achievement-done-array.md)".to_string()
                }
                Type::AchievementInProgressArray => {
                    "[AchievementInProgressArray](../types/achievement-in-progress-array.md)"
                        .to_string()
                }
                Type::VariableItemRandomProperty => {
                    "[VariableItemRandomProperty](../types/variable-item-random-property.md)"
                        .to_string()
                }
                Type::MonsterMoveSplines => {
                    "[MonsterMoveSpline](../types/monster-move-spline.md)".to_string()
                }
                Type::CacheMask => "[CacheMask](../types/cache-mask.md)".to_string(),
                Type::Spell
                | Type::Spell16
                | Type::Item
                | Type::Population
                | Type::Seconds
                | Type::Milliseconds
                | Type::IpAddress
                | Type::Level16
                | Type::Level32
                | Type::Level
                | Type::Gold
                | Type::SizedCString
                | Type::Bool(_)
                | Type::DateTime
                | Type::CString
                | Type::String { .. }
                | Type::Integer(_)
                | Type::FloatingPoint => d.ty().str(),
            };

            let comment = if let Some(d) = d.tags().comment() {
                d.as_doc_table_string()
            } else {
                "".to_string()
            };

            s.wln(format!(
                "| {offset} | {size} / {endian} | {ty} | {name} | {comment} |",
                offset = if let Some(offset) = offset {
                    format!("0x{offset:02X}")
                } else {
                    "-".to_string()
                },
                size = d.ty().doc_size_of(),
                endian = d.ty().doc_endian_str(),
                name = d.name(),
            ));

            if let Some(size) = d.ty().sizes().is_constant() {
                if let Some(off) = offset {
                    *off += size;
                }
            } else {
                *offset = None;
            }
        }
        StructMember::IfStatement(statement) => {
            s.newline();

            print_container_if_statement(s, statement, offset, tags, o);
        }
        StructMember::OptionalStatement(_) => {}
    }
}

fn print_container_item_header(s: &mut Writer) {
    s.wln("| Offset | Size / Endianness | Type | Name | Comment |");
    s.wln("| ------ | ----------------- | ---- | ---- | ------- |");
}

fn print_container_body(s: &mut Writer, e: &Container, o: &Objects) {
    if e.members().iter().any(|m| match m {
        StructMember::Definition(_) => false,
        StructMember::IfStatement(statement) => statement.all_members().any(|m| match m {
            StructMember::Definition(_) => false,
            StructMember::IfStatement(_) => true,
            StructMember::OptionalStatement(_) => false,
        }),
        StructMember::OptionalStatement(_) => false,
    }) {
        return;
    }

    s.wln("### Body");
    s.newline();

    if e.tags().unimplemented() {
        s.wln("The body for this message has not been implemented yet.");
        s.newline();
        return;
    }

    if e.members().is_empty() {
        s.wln("This message has no fields in the body.");
        s.newline();
        return;
    }

    let mut offset = match e.container_type() {
        ContainerType::Msg(_) => Some(0),
        ContainerType::CMsg(_) => Some(6),
        ContainerType::SMsg(_) => {
            if e.tags().contains_wrath() && !e.is_constant_sized() {
                None
            } else {
                Some(4)
            }
        }
        ContainerType::CLogin(_) | ContainerType::SLogin(_) => Some(1),
        ContainerType::Struct => Some(0),
    };

    if !(e.members().len() == 1 && matches!(&e.members()[0], &StructMember::OptionalStatement(_))) {
        print_container_item_header(s);
    }

    for m in e.members() {
        print_container_field(s, m, &mut offset, e.tags(), o);
    }

    if e.rust_object().optional().is_some() {
        s.newline();
        s.wln("Optionally the following fields can be present. This can only be detected by looking at the size of the message.");
        s.newline();

        print_container_item_header(s);

        for m in e.members() {
            match m {
                StructMember::Definition(_) => {}
                StructMember::IfStatement(_) => {}
                StructMember::OptionalStatement(optional) => {
                    for m in optional.members() {
                        print_container_field(s, m, &mut offset, e.tags(), o);
                    }
                }
            }
        }
    }

    s.newline();
}

fn print_container_header(s: &mut Writer, e: &Container) {
    if e.container_type() == ContainerType::Struct {
        return;
    }

    s.wln("### Header");
    s.newline();

    match e.container_type() {
        ContainerType::Msg(_) => s.wln("MSG have a header of either 6 bytes if they are sent from the client (CMSG), or 4 bytes if they are sent from the server (SMSG)."),
        ContainerType::CMsg(_) => {
            s.wln("CMSG have a header of 6 bytes.");
        }
        ContainerType::SMsg(_) => {
            s.wln("SMSG have a header of 4 bytes.");
        }
        ContainerType::SLogin(_) | ContainerType::CLogin(_) => {
            s.wln("Login messages have a header of 1 byte with an opcode. Some messages also have a size field but this is not considered part of the header.")
        }
        _ => unreachable!("unexpected container type"),
    };

    s.newline();

    if matches!(
        e.container_type(),
        ContainerType::CMsg(_) | ContainerType::Msg(_)
    ) {
        s.wln("#### CMSG Header");
        s.newline();

        s.wln("| Offset | Size / Endianness | Type   | Name   | Description |");
        s.wln("| ------ | ----------------- | ------ | ------ | ----------- |");
        s.wln("| 0x00   | 2 / Big           | uint16 | size   | Size of the rest of the message including the opcode field but not including the size field.|");
        s.wln("| 0x02   | 4 / Little        | uint32 | opcode | Opcode that determines which fields the message contains.|");
    }

    if matches!(
        e.container_type(),
        ContainerType::SMsg(_) | ContainerType::Msg(_)
    ) {
        s.wln("#### SMSG Header");
        s.newline();

        s.wln("| Offset | Size / Endianness | Type   | Name   | Description |");
        s.wln("| ------ | ----------------- | ------ | ------ | ----------- |");
        if e.tags().contains_wrath() && !e.is_constant_sized() {
            s.wln("| 0x00   | 2 **OR** 3 / Big           | uint16 **OR** uint16+uint8 | size | Size of the rest of the message including the opcode field but not including the size field. Wrath server messages **can** be 3 bytes. If the first (most significant) size byte has `0x80` set, the header will be 3 bytes, otherwise it is 2.|");
            s.wln("| -      | 2 / Little| uint16 | opcode | Opcode that determines which fields the message contains. |");
        } else {
            s.wln("| 0x00   | 2 / Big           | uint16 | size   | Size of the rest of the message including the opcode field but not including the size field.|");
            s.wln("| 0x02   | 2 / Little        | uint16 | opcode | Opcode that determines which fields the message contains.|");
        }
    }

    if matches!(
        e.container_type(),
        ContainerType::SLogin(_) | ContainerType::CLogin(_)
    ) {
        s.wln("#### Login Header");
        s.newline();

        s.wln("| Offset | Size / Endianness | Type   | Name   | Description |");
        s.wln("| ------ | ----------------- | ------ | ------ | ----------- |");
        s.wln("| 0x00   | 1 / -             | uint8  | opcode | Opcode that determines which fields the message contains.|");
    }

    s.newline();
}

fn get_integer_value(t: &IntegerType, value: &[u8]) -> i128 {
    match t {
        IntegerType::I8 | IntegerType::U8 => value[0].into(),
        IntegerType::I16 | IntegerType::U16 => {
            let value: [u8; 2] = value.try_into().unwrap();
            u16::from_le_bytes(value).into()
        }
        IntegerType::U32 => {
            let value: [u8; 4] = value.try_into().unwrap();
            u32::from_le_bytes(value).into()
        }
        IntegerType::I64 | IntegerType::U64 => {
            let value: [u8; 8] = value.try_into().unwrap();
            u64::from_le_bytes(value).into()
        }
        IntegerType::I32 => {
            let value: [u8; 4] = value.try_into().unwrap();
            i32::from_le_bytes(value).into()
        }
        IntegerType::U48 => {
            let value: [u8; 6] = value.try_into().unwrap();
            let mut a = [0_u8; 4];
            a[0] = value[0];
            a[1] = value[1];
            a[2] = value[2];
            a[3] = value[3];
            let a = u32::from_le_bytes(a);

            let mut b = [0_u8; 2];
            b[0] = value[4];
            b[1] = value[5];
            let b = u16::from_le_bytes(b);

            ((a as u64) | ((b as u64) << 32)).into()
        }
    }
}
