pub(crate) mod mod_files;

use std::fs::read_to_string;
use std::io::{Read, Write};
use std::path::Path;

use heck::ToSnakeCase;

use crate::parser::types::tags::ObjectTags;
use crate::parser::types::version::LoginVersion;
use crate::parser::types::version::{MajorWorldVersion, Version};

pub(crate) fn major_version_to_string(v: &MajorWorldVersion) -> &'static str {
    v.module_name()
}

pub(crate) fn get_world_version_path(version: &MajorWorldVersion) -> String {
    format!("crate::{}", major_version_to_string(version))
}

pub(crate) fn get_login_logon_version_path(version: &LoginVersion) -> String {
    format!("crate::logon::{}", version.as_module_case())
}

pub(crate) fn get_world_shared_path(ty_name: &str, tags: &ObjectTags) -> String {
    format!("crate::shared::{}", tags.shared_module_name(ty_name))
}

pub(crate) fn get_base_internal_shared_path(ty_name: &str, tags: &ObjectTags) -> String {
    format!("crate::shared::{}", tags.shared_module_name(ty_name))
}

pub(crate) fn get_base_shared_path(ty_name: &str, tags: &ObjectTags) -> String {
    format!(
        "wow_world_base::shared::{}",
        tags.shared_module_name(ty_name)
    )
}

pub(crate) fn get_import_path(version: Version) -> String {
    match &version {
        Version::Login(f) => get_login_logon_version_path(f),
        Version::World(f) => get_world_version_path(f),
    }
}

pub(crate) fn write_string_to_file(s: &str, filename: &Path) {
    let f = std::fs::OpenOptions::new()
        .write(true)
        .truncate(true)
        .open(filename);
    let mut f = match f {
        Ok(f) => f,
        Err(_) => {
            let dir = filename.parent().unwrap();
            std::fs::create_dir_all(dir).unwrap();
            std::fs::File::create(filename)
                .unwrap_or_else(|_| panic!("unable to open file: '{}'", filename.to_str().unwrap()))
        }
    };

    f.write_all(s.as_bytes()).unwrap();
}

pub(crate) fn overwrite_if_not_same_contents(s: &str, filename: &Path) {
    let f = read_to_string(filename).unwrap();
    if f != s {
        write_string_to_file(s, filename);
    }
}

pub(crate) fn create_and_overwrite_if_not_same_contents(s: &str, filename: &Path) {
    let f = std::fs::OpenOptions::new().read(true).open(filename);
    match f {
        Ok(mut f) => {
            let mut contents = String::with_capacity(8000);
            f.read_to_string(&mut contents).unwrap();
            if contents != s {
                write_string_to_file(s, filename);
            }
        }
        Err(e) => {
            eprintln!("Unable to open file '{}': '{:?}'", filename.display(), e);
            write_string_to_file(s, filename);
        }
    }
}

pub(crate) fn get_module_name(e: &str) -> String {
    e.to_snake_case()
}

pub(crate) fn get_shared_module_name(e: &str, versions: &[MajorWorldVersion]) -> String {
    let mut s = e.to_snake_case();

    let mut versions = versions.to_vec();
    versions.sort();
    versions.dedup();

    for v in versions {
        s += &format!("_{}", v.module_name());
    }

    s
}

pub fn insert_between(contents: &str, start: &str, end: &str, replace_with: &str) -> String {
    let (before, mid) = contents.split_once(start).unwrap();
    let (_, after) = mid.split_once(end).unwrap();

    let mut s = before.to_string();
    s += start;
    s += "\n";
    s += replace_with;
    s += end;
    s += after;

    s
}

pub(crate) fn overwrite_autogenerate_if_insert_between_not_same(
    path: &Path,
    start: &str,
    end: &str,
    replace_with: &str,
) {
    let contents = match read_to_string(path) {
        Ok(e) => e,
        Err(e) => {
            panic!("File error in '{}' '{}'", path.display(), e);
        }
    };

    let s = insert_between(&contents, start, end, replace_with);
    overwrite_if_not_same_contents(&s, path);
}

pub(crate) fn overwrite_autogenerate_if_not_same_contents(s: &str, path: &Path) {
    overwrite_autogenerate_if_insert_between_not_same(
        path,
        "// AUTOGENERATED_START",
        "// AUTOGENERATED_END",
        s,
    )
}
